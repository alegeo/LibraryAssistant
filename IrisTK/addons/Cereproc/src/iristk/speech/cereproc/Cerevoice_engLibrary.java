package iristk.speech.cereproc;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import java.nio.ByteBuffer;
/**
 * JNA Wrapper for library <b>cerevoice_eng</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Cerevoice_engLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("libcerevoice_eng_shared-3", true, iristk.speech.cereproc.Cerevoice_engLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(iristk.speech.cereproc.Cerevoice_engLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final Cerevoice_engLibrary INSTANCE = (Cerevoice_engLibrary)Native.loadLibrary(iristk.speech.cereproc.Cerevoice_engLibrary.JNA_LIBRARY_NAME, iristk.speech.cereproc.Cerevoice_engLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * Voice load configuration<br>
	 * <i>native declaration : line 42</i><br>
	 * enum values
	 */
	public static interface CPRC_VOICE_LOAD_TYPE {
		/**
		 * All data loaded to memory (fastest, requires most RAM)<br>
		 * All data loaded to memory (fastest, requires most RAM)<br>
		 * <i>native declaration : line 44</i>
		 */
		public static final int CPRC_VOICE_LOAD = 0;
		/**
		 * Audio and index data is read from disk (slowest performance, requires <br>
		 * the least RAM)<br>
		 * Audio and index data is read from disk (slowest performance, requires <br>
		 * the least RAM)<br>
		 * <i>native declaration : line 47</i>
		 */
		public static final int CPRC_VOICE_LOAD_EMB = 1;
		/**
		 * Audio data is read from disk (reasonably fast, relatively low RAM <br>
		 * footprint)<br>
		 * Audio data is read from disk (reasonably fast, relatively low RAM <br>
		 * footprint)<br>
		 * <i>native declaration : line 50</i>
		 */
		public static final int CPRC_VOICE_LOAD_EMB_AUDIO = 2;
		/**
		 * Load using memmap, if supported on the platform<br>
		 * Load using memmap, if supported on the platform<br>
		 * <i>native declaration : line 52</i>
		 */
		public static final int CPRC_VOICE_LOAD_MEMMAP = 3;
		/**
		 * Not used in engine processing<br>
		 * Not used in engine processing<br>
		 * <i>native declaration : line 54</i>
		 */
		public static final int CPRC_VOICE_LOAD_TP = 4;
	};
	/**
	 * <i>native declaration : line 60</i><br>
	 * enum values
	 */
	public static interface CPRCEN_AUDIO_FORMAT {
		/**
		 * Raw linear PCM output<br>
		 * Raw linear PCM output<br>
		 * <i>native declaration : line 62</i>
		 */
		public static final int CPRCEN_RAW = 0;
		/**
		 * RIFF wave output<br>
		 * RIFF wave output<br>
		 * <i>native declaration : line 64</i>
		 */
		public static final int CPRCEN_RIFF = 1;
		/**
		 * AIFF output (commonly used on Mac OS X)<br>
		 * AIFF output (commonly used on Mac OS X)<br>
		 * <i>native declaration : line 66</i>
		 */
		public static final int CPRCEN_AIFF = 2;
	};
	/**
	 * Type of synthesis to use<br>
	 * <i>native declaration : line 70</i><br>
	 * enum values
	 */
	public static interface CPRCEN_SYNTH_TYPE {
		/**
		 * Not used<br>
		 * Not used<br>
		 * <i>native declaration : line 72</i>
		 */
		public static final int CPRCEN_SYNTH_NONE = -1;
		/**
		 * Unit selection synthesis<br>
		 * Unit selection synthesis<br>
		 * <i>native declaration : line 74</i>
		 */
		public static final int CPRCEN_SYNTH_USEL = 0;
		/**
		 * HTS synthesis (if available)<br>
		 * HTS synthesis (if available)<br>
		 * <i>native declaration : line 76</i>
		 */
		public static final int CPRCEN_SYNTH_HTS = 1;
	};
	/**
	 * Type of transcription entry<br>
	 * The transcription holds useful non-speech information about the audio output.<br>
	 * It can be used for a variety of purposes, such as lip syncing for animated <br>
	 * characters (using the phoneme transcriptions), or word highlighting in an <br>
	 * application (using the 'cptk' markers).  User-specified input markers are also<br>
	 * stored in the transcription structure.<br>
	 * <i>native declaration : line 89</i><br>
	 * enum values
	 */
	public static interface CPRC_ABUF_TRANS {
		/**
		 * Phone transcription (phones can also be referred to as 'phonemes')<br>
		 * Phone transcription (phones can also be referred to as 'phonemes')<br>
		 * <i>native declaration : line 91</i>
		 */
		public static final int CPRC_ABUF_TRANS_PHONE = 0;
		/**
		 * Word transcription - these are speech-based word transcriptions, hence <br>
		 * '21' is two word events (twenty one).<br>
		 * Word transcription - these are speech-based word transcriptions, hence <br>
		 * '21' is two word events (twenty one).<br>
		 * <i>native declaration : line 95</i>
		 */
		public static final int CPRC_ABUF_TRANS_WORD = 1;
		/**
		 * Marker transcription, can be user generated or contain CereProc<br>
		 * tokenisation markers.  CereProc token markers have the form <br>
		 * 'cptk_n1_n2_n3_n4', where n1 is the character offset, n2 is the<br>
		 * byte offset, n3 is the number of characters in the word, and n4 <br>
		 * is the number of bytes in the word.<br>
		 * Marker transcription, can be user generated or contain CereProc<br>
		 * tokenisation markers.  CereProc token markers have the form <br>
		 * 'cptk_n1_n2_n3_n4', where n1 is the character offset, n2 is the<br>
		 * byte offset, n3 is the number of characters in the word, and n4 <br>
		 * is the number of bytes in the word.<br>
		 * <i>native declaration : line 102</i>
		 */
		public static final int CPRC_ABUF_TRANS_MARK = 2;
		/**
		 * Error retrieving transcription<br>
		 * Error retrieving transcription<br>
		 * <i>native declaration : line 104</i>
		 */
		public static final int CPRC_ABUF_TRANS_ERROR = 3;
		/**
		 * Number of transcription types<br>
		 * Number of transcription types<br>
		 * <i>native declaration : line 106</i>
		 */
		public static final int CPRC_ABUF_TRANS_TYPES = 4;
	};
	/**
	 * Create an empty engine<br>
	 * The engine is responsible for loading and unloading voices. This<br>
	 * function creates an empty engine, intially with no voices loaded.  The<br>
	 * CPRCEN_engine_load_voice() function must be used to load a voice into<br>
	 * the engine.<br>
	 * Alternatively create an engine using CPRCEN_engine_load() or<br>
	 * CPRCEN_engine_load_config() functions.<br>
	 * Original signature : <code>CPRCEN_engine* CPRCEN_engine_new()</code><br>
	 * <i>native declaration : line 206</i>
	 */
	Pointer CPRCEN_engine_new();
	/**
	 * Create an engine and load a voice<br>
	 * Valid license and voice files must be supplied. Additional voices can<br>
	 * be loaded with CPRCEN_engine_load_voice().<br>
	 * Returns NULL if there has been an error.<br>
	 * Original signature : <code>CPRCEN_engine* CPRCEN_engine_load(const char*, const char*)</code><br>
	 * <i>native declaration : line 215</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_load(java.lang.String, java.lang.String)} and {@link #CPRCEN_engine_load(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer CPRCEN_engine_load(Pointer licensef, Pointer voicef);
	/**
	 * Create an engine and load a voice<br>
	 * Valid license and voice files must be supplied. Additional voices can<br>
	 * be loaded with CPRCEN_engine_load_voice().<br>
	 * Returns NULL if there has been an error.<br>
	 * Original signature : <code>CPRCEN_engine* CPRCEN_engine_load(const char*, const char*)</code><br>
	 * <i>native declaration : line 215</i>
	 */
	Pointer CPRCEN_engine_load(String licensef, String voicef);
	/**
	 * Create an engine and load a voice, with configuration<br>
	 * Valid license and voice files must be supplied, along with a configuration <br>
	 * file. Additional voices can be loaded with CPRCEN_engine_load_voice().<br>
	 * Returns NULL if there has been an error.<br>
	 * Original signature : <code>CPRCEN_engine* CPRCEN_engine_load_config(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : line 224</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_load_config(java.lang.String, java.lang.String, java.lang.String)} and {@link #CPRCEN_engine_load_config(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer CPRCEN_engine_load_config(Pointer licensef, Pointer voicef, Pointer voice_configf);
	/**
	 * Create an engine and load a voice, with configuration<br>
	 * Valid license and voice files must be supplied, along with a configuration <br>
	 * file. Additional voices can be loaded with CPRCEN_engine_load_voice().<br>
	 * Returns NULL if there has been an error.<br>
	 * Original signature : <code>CPRCEN_engine* CPRCEN_engine_load_config(const char*, const char*, const char*)</code><br>
	 * <i>native declaration : line 224</i>
	 */
	Pointer CPRCEN_engine_load_config(String licensef, String voicef, String voice_configf);
	/**
	 * Load a voice into the engine <br>
	 * A voice file and valid license must be supplied.  To use the default <br>
	 * configuration pass an empty string as the configf argument.  See the load type<br>
	 * documentation for information on the different load configurations.<br>
	 * Multiple voices can be loaded using this function.  The most recently loaded<br>
	 * voice becomes the default voice for CPRCEN_engine_open_default_channel().<br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRCEN_engine_load_voice(CPRCEN_engine*, const char*, const char*, const char*, CPRC_VOICE_LOAD_TYPE)</code><br>
	 * <i>native declaration : line 239</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_load_voice(com.sun.jna.Pointer, java.lang.String, java.lang.String, java.lang.String, int)} and {@link #CPRCEN_engine_load_voice(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, int)} instead<br>
	 * @param load_type @see CPRC_VOICE_LOAD_TYPE
	 */
	@Deprecated 
	int CPRCEN_engine_load_voice(Pointer eng, Pointer licensef, Pointer configf, Pointer voicef, int load_type);
	/**
	 * Load a voice into the engine <br>
	 * A voice file and valid license must be supplied.  To use the default <br>
	 * configuration pass an empty string as the configf argument.  See the load type<br>
	 * documentation for information on the different load configurations.<br>
	 * Multiple voices can be loaded using this function.  The most recently loaded<br>
	 * voice becomes the default voice for CPRCEN_engine_open_default_channel().<br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRCEN_engine_load_voice(CPRCEN_engine*, const char*, const char*, const char*, CPRC_VOICE_LOAD_TYPE)</code><br>
	 * <i>native declaration : line 239</i><br>
	 * @param load_type @see CPRC_VOICE_LOAD_TYPE
	 */
	int CPRCEN_engine_load_voice(Pointer eng, String licensef, String configf, String voicef, int load_type);
	/**
	 * Unload a voice from the engine<br>
	 * Any open channels using the voice are closed automatically.<br>
	 * Note that it is not necessary to unload voices prior to calling<br>
	 * CPRCEN_engine_delete().  CPRCEN_engine_get_voice_count() and<br>
	 * CPRCEN_engine_get_voice_info() should be used to check the loaded<br>
	 * voices.<br>
	 * The index will be less than the number returned by<br>
	 * CPRCEN_engine_get_voice_count().<br>
	 * On success, returns the number of voices currently loaded.  Returns -1<br>
	 * if there has been an error.<br>
	 * Original signature : <code>int CPRCEN_engine_unload_voice(CPRCEN_engine*, int)</code><br>
	 * <i>native declaration : line 260</i>
	 */
	int CPRCEN_engine_unload_voice(Pointer eng, int voice_index);
	/**
	 * Delete and clean up the engine<br>
	 * Deleting the engine cleans up any voices that have been loaded, as well as any<br>
	 * open channels.<br>
	 * Original signature : <code>void CPRCEN_engine_delete(CPRCEN_engine*)</code><br>
	 * <i>native declaration : line 267</i>
	 */
	void CPRCEN_engine_delete(Pointer eng);
	/**
	 * Load user lexicon <br>
	 * Simple entries are in the format:<br>
	 * hello h_\@0_l_ou1<br>
	 * The index will be less than the number returned by<br>
	 * CPRCEN_engine_get_voice_count().<br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRCEN_engine_load_user_lexicon(CPRCEN_engine*, int, const char*)</code><br>
	 * <i>native declaration : line 279</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_load_user_lexicon(com.sun.jna.Pointer, int, java.lang.String)} and {@link #CPRCEN_engine_load_user_lexicon(com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int CPRCEN_engine_load_user_lexicon(Pointer eng, int voice_index, Pointer fname);
	/**
	 * Load user lexicon <br>
	 * Simple entries are in the format:<br>
	 * hello h_\@0_l_ou1<br>
	 * The index will be less than the number returned by<br>
	 * CPRCEN_engine_get_voice_count().<br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRCEN_engine_load_user_lexicon(CPRCEN_engine*, int, const char*)</code><br>
	 * <i>native declaration : line 279</i>
	 */
	int CPRCEN_engine_load_user_lexicon(Pointer eng, int voice_index, String fname);
	/**
	 * Return the number of loaded voices<br>
	 * Original signature : <code>int CPRCEN_engine_get_voice_count(CPRCEN_engine*)</code><br>
	 * <i>native declaration : line 289</i>
	 */
	int CPRCEN_engine_get_voice_count(Pointer eng);
	/**
	 * Get voice information <br>
	 * Returns a char containing voice information.  The key is a string used to<br>
	 * look up the information about the voice. Useful keys:<br>
	 * - SAMPLE_RATE - sample rate, in hertz, of the voice (e.g. '22050')<br>
	 * - VOICE_NAME - name of the CereProc voice (e.g. 'Sarah')<br>
	 * - LANGUAGE_CODE_ISO - two-letter ISO language code (e.g. 'en')<br>
	 * - COUNTRY_CODE_ISO - two-letter ISO country code (e.g. 'GB')<br>
	 * - SEX - gender of the voice, ('male' or 'female')<br>
	 * - LANGUAGE_CODE_MICROSOFT - Language code used by MS SAPI (e.g. '809')<br>
	 * - COUNTRY - human-readable country description (e.g. 'Great Britain')<br>
	 * - REGION - human-readable region description (e.g. 'England')<br>
	 * The index will be less than the number returned by<br>
	 * CPRCEN_engine_get_voice_count().<br>
	 * Returns an empty string if the key is invalid or the voice does not exist.<br>
	 * Original signature : <code>char* CPRCEN_engine_get_voice_info(CPRCEN_engine*, int, const char*)</code><br>
	 * <i>native declaration : line 309</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_get_voice_info(com.sun.jna.Pointer, int, java.lang.String)} and {@link #CPRCEN_engine_get_voice_info(com.sun.jna.Pointer, int, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer CPRCEN_engine_get_voice_info(Pointer eng, int voice_index, Pointer key);
	/**
	 * Get voice information <br>
	 * Returns a char containing voice information.  The key is a string used to<br>
	 * look up the information about the voice. Useful keys:<br>
	 * - SAMPLE_RATE - sample rate, in hertz, of the voice (e.g. '22050')<br>
	 * - VOICE_NAME - name of the CereProc voice (e.g. 'Sarah')<br>
	 * - LANGUAGE_CODE_ISO - two-letter ISO language code (e.g. 'en')<br>
	 * - COUNTRY_CODE_ISO - two-letter ISO country code (e.g. 'GB')<br>
	 * - SEX - gender of the voice, ('male' or 'female')<br>
	 * - LANGUAGE_CODE_MICROSOFT - Language code used by MS SAPI (e.g. '809')<br>
	 * - COUNTRY - human-readable country description (e.g. 'Great Britain')<br>
	 * - REGION - human-readable region description (e.g. 'England')<br>
	 * The index will be less than the number returned by<br>
	 * CPRCEN_engine_get_voice_count().<br>
	 * Returns an empty string if the key is invalid or the voice does not exist.<br>
	 * Original signature : <code>char* CPRCEN_engine_get_voice_info(CPRCEN_engine*, int, const char*)</code><br>
	 * <i>native declaration : line 309</i>
	 */
	Pointer CPRCEN_engine_get_voice_info(Pointer eng, int voice_index, String key);
	/**
	 * Create a new channel handle<br>
	 * The engine is searched for the best match of voice name, ISO language/region <br>
	 * code, and sample rate (voice name is preferred). <br>
	 * Returns FALSE if unable to create channel.<br>
	 * Original signature : <code>CPRCEN_channel_handle CPRCEN_engine_open_channel(CPRCEN_engine*, const char*, const char*, const char*, const char*)</code><br>
	 * <i>native declaration : line 329</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_open_channel(com.sun.jna.Pointer, java.lang.String, java.lang.String, java.lang.String, java.lang.String)} and {@link #CPRCEN_engine_open_channel(com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Cerevoice_engLibrary.CPRCEN_channel_handle CPRCEN_engine_open_channel(Pointer eng, Pointer iso_language_code, Pointer iso_region_code, Pointer voice_name, Pointer srate);
	/**
	 * Create a new channel handle<br>
	 * The engine is searched for the best match of voice name, ISO language/region <br>
	 * code, and sample rate (voice name is preferred). <br>
	 * Returns FALSE if unable to create channel.<br>
	 * Original signature : <code>CPRCEN_channel_handle CPRCEN_engine_open_channel(CPRCEN_engine*, const char*, const char*, const char*, const char*)</code><br>
	 * <i>native declaration : line 329</i>
	 */
	Cerevoice_engLibrary.CPRCEN_channel_handle CPRCEN_engine_open_channel(Pointer eng, String iso_language_code, String iso_region_code, String voice_name, String srate);
	/**
	 * Return a new channel handle for the default voice<br>
	 * The default channel is useful when a single voice is loaded.  When using <br>
	 * multiple voices, the CPRCEN_engine_open_channel() function can select between<br>
	 * then when opening a channel.<br>
	 * Returns FALSE if unable to create channel.<br>
	 * Original signature : <code>CPRCEN_channel_handle CPRCEN_engine_open_default_channel(CPRCEN_engine*)</code><br>
	 * <i>native declaration : line 343</i>
	 */
	//Cerevoice_engLibrary.CPRCEN_channel_handle CPRCEN_engine_open_default_channel(Pointer eng);
	int CPRCEN_engine_open_default_channel(Pointer eng);
	/**
	 * Reset a channel<br>
	 * This function is safe to call inside the callback function.  Future processing <br>
	 * is halted.  The channel is cleaned up by the engine for reuse. It does not<br>
	 * clear the callback - the CPRCEN_engine_clear_callback() should be used to clear<br>
	 * the callback data.<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_reset(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 354</i>
	 */
	int CPRCEN_engine_channel_reset(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Release and delete a channel <br>
	 * This function cannot be called within the callback function.<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_close(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 363</i>
	 */
	int CPRCEN_engine_channel_close(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Set a callback function for processing audio incrementally<br>
	 * The callback is fired phrase-by-phrase to allow incremental, low latency, <br>
	 * processing of the speech output. The user_data pointer is used to store <br>
	 * user-configurable information.<br>
	 * After a user callback has been set, speak calls do not return an audio buffer. <br>
	 * Example callback:<br>
	 * \code<br>
	 * // A simple example callback function, appends audio to a file<br>
	 * void channel_callback(CPRC_abuf * abuf, void * userdata) {<br>
	 * char * f = (char *) userdata;<br>
	 * CPRC_riff_append(abuf, f);<br>
	 * }<br>
	 * // The callback would be initialised and set like this:<br>
	 * char * outfile = "out.wav";<br>
	 * CPRCEN_engine_set_callback(eng, chan, (void *)outfile, channel_callback);<br>
	 * \endcode<br>
	 * The tts_callback.c and tts_callback.py example programs contain<br>
	 * more extensive callback demonstration code.<br>
	 * Returns FALSE if unable to set the callback.<br>
	 * Original signature : <code>int CPRCEN_engine_set_callback(CPRCEN_engine*, CPRCEN_channel_handle, void*, cprcen_channel_callback)</code><br>
	 * <i>native declaration : line 396</i>
	 */
	int CPRCEN_engine_set_callback(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, Pointer userdata, Cerevoice_engLibrary.cprcen_channel_callback callback);
	/**
	 * Clear the callback data<br>
	 * After a user callback has been cleared, speak calls return an audio buffer. <br>
	 * Returns FALSE if unable to clear the callback.<br>
	 * Original signature : <code>int CPRCEN_engine_clear_callback(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 407</i>
	 */
	int CPRCEN_engine_clear_callback(Pointer eng, int chan);
	/**
	 * Get the pointer to the user data on a channel <br>
	 * Returns NULL if the user data cannot be retrieved.<br>
	 * Original signature : <code>void* CPRCEN_engine_get_channel_userdata(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 414</i>
	 */
	Pointer CPRCEN_engine_get_channel_userdata(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Speak input text or XML<br>
	 * If no callback is set, a default callback is used and output is appended to <br>
	 * the returned audio buffer.  To clear the output between requests, use the <br>
	 * CPRCEN_engine_clear_callback() function.<br>
	 * If a callback has been set, audio will be processed by the callback function.<br>
	 * If flush is TRUE, regard text as complete and flush the output buffer.<br>
	 * Returns NULL if there is an error (e.g if the channel is not open).<br>
	 * Original signature : <code>CPRC_abuf* CPRCEN_engine_channel_speak(CPRCEN_engine*, CPRCEN_channel_handle, const char*, int, int)</code><br>
	 * <i>native declaration : line 432</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_channel_speak(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, java.lang.String, int, int)} and {@link #CPRCEN_engine_channel_speak(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated 
	Pointer CPRCEN_engine_channel_speak(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, Pointer text, int textlen, int flush);
	/**
	 * Speak input text or XML<br>
	 * If no callback is set, a default callback is used and output is appended to <br>
	 * the returned audio buffer.  To clear the output between requests, use the <br>
	 * CPRCEN_engine_clear_callback() function.<br>
	 * If a callback has been set, audio will be processed by the callback function.<br>
	 * If flush is TRUE, regard text as complete and flush the output buffer.<br>
	 * Returns NULL if there is an error (e.g if the channel is not open).<br>
	 * Original signature : <code>CPRC_abuf* CPRCEN_engine_channel_speak(CPRCEN_engine*, CPRCEN_channel_handle, const char*, int, int)</code><br>
	 * <i>native declaration : line 432</i>
	 */
	//Pointer CPRCEN_engine_channel_speak(Pointer eng, int chan, byte[] text, int textlen, int flush);
	Pointer CPRCEN_engine_channel_speak(Pointer eng, int chan, ByteBuffer text, int textlen, int flush);
	/**
	 * Get information about the voice <br>
	 * See the CPRCEN_engine_get_voice_info() section for information on the types of<br>
	 * information that are available, and example keys.<br>
	 * Returns an empty string if the key is invalid.<br>
	 * Original signature : <code>char* CPRCEN_channel_get_voice_info(CPRCEN_engine*, CPRCEN_channel_handle, const char*)</code><br>
	 * <i>native declaration : line 450</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_channel_get_voice_info(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, java.lang.String)} and {@link #CPRCEN_channel_get_voice_info(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	Pointer CPRCEN_channel_get_voice_info(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, Pointer key);
	/**
	 * Get information about the voice <br>
	 * See the CPRCEN_engine_get_voice_info() section for information on the types of<br>
	 * information that are available, and example keys.<br>
	 * Returns an empty string if the key is invalid.<br>
	 * Original signature : <code>char* CPRCEN_channel_get_voice_info(CPRCEN_engine*, CPRCEN_channel_handle, const char*)</code><br>
	 * <i>native declaration : line 450</i>
	 */
	Pointer CPRCEN_channel_get_voice_info(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, String key);
	/**
	 * Get the current synthesis type for the channel<br>
	 * Original signature : <code>CPRCEN_SYNTH_TYPE CPRCEN_channel_synth_get_type(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 460</i>
	 */
	/**
	 * @see CPRCEN_SYNTH_TYPE
	 */int CPRCEN_channel_synth_get_type(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Write audio generated on the channel to a file <br>
	 * If the file exists, it is overwritten.  Subsequent<br>
	 * CPRCEN_engine_channel_speak() calls append to the file. If the<br>
	 * CPRCEN_engine_clear_callback() function is called, the output file<br>
	 * will be overwritten again on a speak.  To continually append to a<br>
	 * file, use the CPRCEN_engine_channel_append_to_file() function.<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_to_file(CPRCEN_engine*, CPRCEN_channel_handle, char*, CPRCEN_AUDIO_FORMAT)</code><br>
	 * <i>native declaration : line 479</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_channel_to_file(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, java.nio.ByteBuffer, int)} and {@link #CPRCEN_engine_channel_to_file(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, com.sun.jna.Pointer, int)} instead<br>
	 * @param format @see CPRCEN_AUDIO_FORMAT
	 */
	@Deprecated 
	int CPRCEN_engine_channel_to_file(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, Pointer fname, int format);
	/**
	 * Write audio generated on the channel to a file <br>
	 * If the file exists, it is overwritten.  Subsequent<br>
	 * CPRCEN_engine_channel_speak() calls append to the file. If the<br>
	 * CPRCEN_engine_clear_callback() function is called, the output file<br>
	 * will be overwritten again on a speak.  To continually append to a<br>
	 * file, use the CPRCEN_engine_channel_append_to_file() function.<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_to_file(CPRCEN_engine*, CPRCEN_channel_handle, char*, CPRCEN_AUDIO_FORMAT)</code><br>
	 * <i>native declaration : line 479</i><br>
	 * @param format @see CPRCEN_AUDIO_FORMAT
	 */
	//int CPRCEN_engine_channel_to_file(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, ByteBuffer fname, int format);
	int CPRCEN_engine_channel_to_file(Pointer eng, int chan, ByteBuffer fname, int format);
	/**
	 * Append audio generated on the channel to a file <br>
	 * If the file does not exist, it will be created.  Audio continues to be<br>
	 * appended to the file after calling CPRCEN_engine_clear_callback().<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_append_to_file(CPRCEN_engine*, CPRCEN_channel_handle, char*, CPRCEN_AUDIO_FORMAT)</code><br>
	 * <i>native declaration : line 491</i><br>
	 * @deprecated use the safer methods {@link #CPRCEN_engine_channel_append_to_file(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, java.nio.ByteBuffer, int)} and {@link #CPRCEN_engine_channel_append_to_file(com.sun.jna.Pointer, iuro.system.cereproc.jna.Cerevoice_engLibrary.CPRCEN_channel_handle, com.sun.jna.Pointer, int)} instead<br>
	 * @param format @see CPRCEN_AUDIO_FORMAT
	 */
	@Deprecated 
	int CPRCEN_engine_channel_append_to_file(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, Pointer fname, int format);
	/**
	 * Append audio generated on the channel to a file <br>
	 * If the file does not exist, it will be created.  Audio continues to be<br>
	 * appended to the file after calling CPRCEN_engine_clear_callback().<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_append_to_file(CPRCEN_engine*, CPRCEN_channel_handle, char*, CPRCEN_AUDIO_FORMAT)</code><br>
	 * <i>native declaration : line 491</i><br>
	 * @param format @see CPRCEN_AUDIO_FORMAT
	 */
	int CPRCEN_engine_channel_append_to_file(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan, ByteBuffer fname, int format);
	/**
	 * Stop audio generated on the channel being appended to a file <br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_engine_channel_no_file(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 500</i>
	 */
	int CPRCEN_engine_channel_no_file(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Set HTS mode, if available <br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_channel_synth_type_hts(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 508</i>
	 */
	int CPRCEN_channel_synth_type_hts(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Set unit selection mode<br>
	 * Returns FALSE if there is an error.<br>
	 * Original signature : <code>int CPRCEN_channel_synth_type_usel(CPRCEN_engine*, CPRCEN_channel_handle)</code><br>
	 * <i>native declaration : line 515</i>
	 */
	int CPRCEN_channel_synth_type_usel(Pointer eng, Cerevoice_engLibrary.CPRCEN_channel_handle chan);
	/**
	 * Save the audio data as a RIFF wave file <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_save(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 590</i><br>
	 * @deprecated use the safer methods {@link #CPRC_riff_save(com.sun.jna.Pointer, java.lang.String)} and {@link #CPRC_riff_save(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int CPRC_riff_save(Pointer wav, Pointer fname);
	/**
	 * Save the audio data as a RIFF wave file <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_save(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 590</i>
	 */
	int CPRC_riff_save(Pointer wav, String fname);
	/**
	 * Append the audio data to a RIFF wave file <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_append(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 596</i><br>
	 * @deprecated use the safer methods {@link #CPRC_riff_append(com.sun.jna.Pointer, java.lang.String)} and {@link #CPRC_riff_append(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int CPRC_riff_append(Pointer wav, Pointer fname);
	/**
	 * Append the audio data to a RIFF wave file <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_append(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 596</i>
	 */
	int CPRC_riff_append(Pointer wav, String fname);
	/**
	 * Save the transcription section of the audio buffer <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_save_trans(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 602</i><br>
	 * @deprecated use the safer methods {@link #CPRC_riff_save_trans(com.sun.jna.Pointer, java.lang.String)} and {@link #CPRC_riff_save_trans(com.sun.jna.Pointer, com.sun.jna.Pointer)} instead
	 */
	@Deprecated 
	int CPRC_riff_save_trans(Pointer wav, Pointer fname);
	/**
	 * Save the transcription section of the audio buffer <br>
	 * Returns FALSE if there has been an error.<br>
	 * Original signature : <code>int CPRC_riff_save_trans(CPRC_abuf*, const char*)</code><br>
	 * <i>native declaration : line 602</i>
	 */
	int CPRC_riff_save_trans(Pointer wav, String fname);
	/**
	 * Copy audio to a RIFF buffer<br>
	 * Copy the audio to a fixed in-memory buffer containing a RIFF header<br>
	 * and the audio data.  This can be useful for playing back in-memory<br>
	 * audio in some applications, avoiding the need to write audio to disk.<br>
	 * Original signature : <code>CPTP_fixedbuf* CPRC_riff_buffer(CPRC_abuf*)</code><br>
	 * <i>native declaration : line 616</i>
	 */
	CPTP_fixedbuf CPRC_riff_buffer(Pointer wav);
	/**
	 * Delete a fixed buffer <br>
	 * Delete a buffer as returned by CPRC_riff_buffer().<br>
	 * Original signature : <code>void CPTP_fixedbuf_delete(CPTP_fixedbuf*)</code><br>
	 * <i>native declaration : line 622</i>
	 */
	void CPTP_fixedbuf_delete(CPTP_fixedbuf fb);
	/**
	 * Make a copy of an audio buffer <br>
	 * Make a copy of an audio buffer.  Useful if the user wishes to process<br>
	 * audio on a separate thread and allow the callback to continue.<br>
	 * Original signature : <code>CPRC_abuf* CPRC_abuf_copy(CPRC_abuf*)</code><br>
	 * <i>native declaration : line 629</i>
	 */
	/// Undefined type
	public static interface CPRCEN_channel_handle {
		
	};
	/*
	/// Undefined type
	public static interface byte {
		
	};
	*/
	/// Undefined type
	public static interface CPRC_abuf_dsp {
		
	};
	/// Undefined type
	public static interface CPRC_abuf {
		
	};
	/// Undefined type
	public static interface CPRCEN_engine {
		
	};
	/// Undefined type
	public static interface cprcen_channel_callback {
		
	};
}
