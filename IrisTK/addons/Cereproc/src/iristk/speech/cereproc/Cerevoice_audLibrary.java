package iristk.speech.cereproc;
import com.ochafik.lang.jnaerator.runtime.LibraryExtractor;
import com.ochafik.lang.jnaerator.runtime.Mangling;
import com.sun.jna.Library;
import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.jna.Pointer;
import com.sun.jna.ptr.ShortByReference;
import java.nio.ByteBuffer;
import java.nio.ShortBuffer;
/**
 * JNA Wrapper for library <b>cerevoice_aud</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface Cerevoice_audLibrary extends Library {
	public static final String JNA_LIBRARY_NAME = LibraryExtractor.getLibraryPath("cerevoice_aud", true, iristk.speech.cereproc.Cerevoice_audLibrary.class);
	public static final NativeLibrary JNA_NATIVE_LIB = NativeLibrary.getInstance(iristk.speech.cereproc.Cerevoice_audLibrary.JNA_LIBRARY_NAME, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	public static final Cerevoice_audLibrary INSTANCE = (Cerevoice_audLibrary)Native.loadLibrary(iristk.speech.cereproc.Cerevoice_audLibrary.JNA_LIBRARY_NAME, iristk.speech.cereproc.Cerevoice_audLibrary.class, com.ochafik.lang.jnaerator.runtime.MangledFunctionMapper.DEFAULT_OPTIONS);
	/**
	 * Status of an audio sound cue <br>
	 * Users wanting to monitor the status of a cue must use the<br>
	 * CPRC_sc_audio_short() function to create the cues, and then delete the<br>
	 * cues themselves. CPRC_sc_audio_short_disposable() must not be used, as<br>
	 * the cues are automatically deleted after playback.<br>
	 * <i>native declaration : line 35</i><br>
	 * enum values
	 */
	public static interface CPRC_SC_STAT {
		/**
		 * Waiting to be played<br>
		 * Waiting to be played<br>
		 * <i>native declaration : line 37</i>
		 */
		public static final int CPRC_SC_WAITING = 0;
		/**
		 * In the middle of being played<br>
		 * In the middle of being played<br>
		 * <i>native declaration : line 39</i>
		 */
		public static final int CPRC_SC_PLAYING_MID = 1;
		/**
		 * About to finish playing<br>
		 * About to finish playing<br>
		 * <i>native declaration : line 41</i>
		 */
		public static final int CPRC_SC_PLAYING_LAST_FRAME = 2;
		/**
		 * Playback complete<br>
		 * Playback complete<br>
		 * <i>native declaration : line 43</i>
		 */
		public static final int CPRC_SC_PLAYED = 3;
	};
	/**
	 * Playback status of an audio sound cue<br>
	 * If it is successful (TRUE), it also says whether the stream had to be restarted<br>
	 * (a pause is likely before the sound cue if a restart has occurred).<br>
	 * <i>native declaration : line 51</i><br>
	 * enum values
	 */
	public static interface CPRCTHD_CUE {
		/**
		 * Playback failed<br>
		 * Playback failed<br>
		 * <i>native declaration : line 53</i>
		 */
		public static final int CPRC_CUE_ERROR = 0;
		/**
		 * Playback was successful<br>
		 * Playback was successful<br>
		 * <i>native declaration : line 55</i>
		 */
		public static final int CPRC_CUE_OK = 1;
		/**
		 * Playback was successful, but the stream had to be restarted<br>
		 * Playback was successful, but the stream had to be restarted<br>
		 * <i>native declaration : line 57</i>
		 */
		public static final int CPRC_CUE_RESTART = 2;
	};
	/**
	 * Create a new sound cue player<br>
	 * The player will play 16 bit audio. The sample rate must be set. If the<br>
	 * system does not support the sample rate, the player will not be<br>
	 * created.<br>
	 * Original signature : <code>CPRC_sc_player* CPRC_sc_player_new(int)</code><br>
	 * <i>native declaration : line 83</i>
	 */
	@Mangling({"_Z18CPRC_sc_player_newi", "?CPRC_sc_player_new@@YAPA14CPRC_sc_playerH@Z"}) 
	Pointer CPRC_sc_player_new(int sample_rate);
	/**
	 * Clean up sound cue player <br>
	 * Clean up the player. If CPRC_sc_audio_short() has been used to create<br>
	 * the sound cues, the user must clean up the cues themselves.<br>
	 * Original signature : <code>void CPRC_sc_player_delete(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 90</i>
	 */
	@Mangling({"_Z21CPRC_sc_player_deleteP14CPRC_sc_player", "?CPRC_sc_player_delete@@YAXPA14CPRC_sc_player@Z"}) 
	void CPRC_sc_player_delete(Pointer player);
	/**
	 * Current stream time of a player<br>
	 * Returns how much audio has been played on a busy stream. This is used<br>
	 * to synchronise played audio with other processes (such as word<br>
	 * highlighting).<br>
	 * Original signature : <code>double CPRC_sc_player_stream_time(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 98</i>
	 */
	@Mangling({"_Z26CPRC_sc_player_stream_timeP14CPRC_sc_player", "?CPRC_sc_player_stream_time@@YANPA14CPRC_sc_player@Z"}) 
	double CPRC_sc_player_stream_time(Pointer player);
	/**
	 * Create an audio sound cue<br>
	 * Create and audio sound cue from a buffer of shorts.  The cues created<br>
	 * must be cleaned up by the user with the CPRC_sc_audio_delete()<br>
	 * function.  These cues can be monitored for their status and, start<br>
	 * time etc.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short(short*, int)</code><br>
	 * <i>native declaration : line 107</i><br>
	 * @deprecated use the safer methods {@link #CPRC_sc_audio_short(java.nio.ShortBuffer, int)} and {@link #CPRC_sc_audio_short(com.sun.jna.ptr.ShortByReference, int)} instead
	 */
	@Mangling({"_Z19CPRC_sc_audio_shortPii", "?CPRC_sc_audio_short@@YAPA13CPRC_sc_audioPAHH@Z"}) 
	@Deprecated 
	Pointer CPRC_sc_audio_short(ShortByReference data, int len);
	/**
	 * Create an audio sound cue<br>
	 * Create and audio sound cue from a buffer of shorts.  The cues created<br>
	 * must be cleaned up by the user with the CPRC_sc_audio_delete()<br>
	 * function.  These cues can be monitored for their status and, start<br>
	 * time etc.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short(short*, int)</code><br>
	 * <i>native declaration : line 107</i>
	 */
	@Mangling({"_Z19CPRC_sc_audio_shortPii", "?CPRC_sc_audio_short@@YAPA13CPRC_sc_audioPAHH@Z"}) 
	Pointer CPRC_sc_audio_short(ShortBuffer data, int len);
	/**
	 * Create a disposable audio sound cue<br>
	 * Create a disposable audio sound cue from a buffer of shorts. This<br>
	 * buffer is cleaned up automatically after it is played, so should not be<br>
	 * polled for cue status updates.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short_disposable(short*, int)</code><br>
	 * <i>native declaration : line 115</i><br>
	 * @deprecated use the safer methods {@link #CPRC_sc_audio_short_disposable(java.nio.ShortBuffer, int)} and {@link #CPRC_sc_audio_short_disposable(com.sun.jna.ptr.ShortByReference, int)} instead
	 */
	@Mangling({"_Z30CPRC_sc_audio_short_disposablePii", "?CPRC_sc_audio_short_disposable@@YAPA13CPRC_sc_audioPAHH@Z"}) 
	@Deprecated 
	Pointer CPRC_sc_audio_short_disposable(ShortByReference data, int len);
	/**
	 * Create a disposable audio sound cue<br>
	 * Create a disposable audio sound cue from a buffer of shorts. This<br>
	 * buffer is cleaned up automatically after it is played, so should not be<br>
	 * polled for cue status updates.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short_disposable(short*, int)</code><br>
	 * <i>native declaration : line 115</i>
	 */
	@Mangling({"_Z30CPRC_sc_audio_short_disposablePii", "?CPRC_sc_audio_short_disposable@@YAPA13CPRC_sc_audioPAHH@Z"}) 
	Pointer CPRC_sc_audio_short_disposable(ShortBuffer data, int len);
	/**
	 * Create an audio sound cue<br>
	 * Create an audio sound cue from a buffer of shorts, with control over<br>
	 * allocation.  Memory allocation is the default behaviour for<br>
	 * CPRC_sc_audio_short() and CPRC_sc_audio_short_disposable(). This<br>
	 * function cannot be used to create disposable cues.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short_alloc(short*, int, int)</code><br>
	 * <i>native declaration : line 124</i><br>
	 * @deprecated use the safer methods {@link #CPRC_sc_audio_short_alloc(java.nio.ShortBuffer, int, int)} and {@link #CPRC_sc_audio_short_alloc(com.sun.jna.ptr.ShortByReference, int, int)} instead
	 */
	@Mangling({"_Z25CPRC_sc_audio_short_allocPiii", "?CPRC_sc_audio_short_alloc@@YAPA13CPRC_sc_audioPAHHH@Z"}) 
	@Deprecated 
	Pointer CPRC_sc_audio_short_alloc(ShortByReference data, int len, int alloc);
	/**
	 * Create an audio sound cue<br>
	 * Create an audio sound cue from a buffer of shorts, with control over<br>
	 * allocation.  Memory allocation is the default behaviour for<br>
	 * CPRC_sc_audio_short() and CPRC_sc_audio_short_disposable(). This<br>
	 * function cannot be used to create disposable cues.<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_short_alloc(short*, int, int)</code><br>
	 * <i>native declaration : line 124</i>
	 */
	@Mangling({"_Z25CPRC_sc_audio_short_allocPiii", "?CPRC_sc_audio_short_alloc@@YAPA13CPRC_sc_audioPAHHH@Z"}) 
	Pointer CPRC_sc_audio_short_alloc(ShortBuffer data, int len, int alloc);
	/**
	 * Create an audio sound cue from a Python string (SWIG wrapped)<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_pythonstr(wavedata*, int)</code><br>
	 * <i>native declaration : line 127</i><br>
	 * @deprecated use the safer methods {@link #CPRC_sc_audio_pythonstr(java.nio.ByteBuffer, int)} and {@link #CPRC_sc_audio_pythonstr(com.sun.jna.Pointer, int)} instead
	 */
	@Mangling({"_Z23CPRC_sc_audio_pythonstrPci", "?CPRC_sc_audio_pythonstr@@YAPA13CPRC_sc_audioPADH@Z"}) 
	@Deprecated 
	Pointer CPRC_sc_audio_pythonstr(Pointer data, int len);
	/**
	 * Create an audio sound cue from a Python string (SWIG wrapped)<br>
	 * Original signature : <code>CPRC_sc_audio* CPRC_sc_audio_pythonstr(wavedata*, int)</code><br>
	 * <i>native declaration : line 127</i>
	 */
	@Mangling({"_Z23CPRC_sc_audio_pythonstrPci", "?CPRC_sc_audio_pythonstr@@YAPA13CPRC_sc_audioPADH@Z"}) 
	Pointer CPRC_sc_audio_pythonstr(ByteBuffer data, int len);
	/**
	 * Status of an audio sound cue <br>
	 * The sound cue should not be deleted until its status is set to played.<br>
	 * Do not use this function on disposable sound cues, as they are cleaned<br>
	 * up automatically after playback.<br>
	 * Original signature : <code>CPRC_SC_STAT CPRC_sc_audio_status(CPRC_sc_audio*)</code><br>
	 * <i>native declaration : line 135</i>
	 */
	@Mangling({"_Z20CPRC_sc_audio_statusP13CPRC_sc_audio", "?CPRC_sc_audio_status@@YA12CPRC_SC_STATPA13CPRC_sc_audio@Z"}) 
	/**
	 * @see CPRC_SC_STAT
	 */int CPRC_sc_audio_status(Pointer audio);
	/**
	 * Start time of a playing (or played) audio cue <br>
	 * Do not use this function on disposable sound cues, as they are cleaned<br>
	 * up automatically after playback.<br>
	 * Original signature : <code>double CPRC_sc_audio_start_time(CPRC_sc_audio*)</code><br>
	 * <i>native declaration : line 142</i>
	 */
	@Mangling({"_Z24CPRC_sc_audio_start_timeP13CPRC_sc_audio", "?CPRC_sc_audio_start_time@@YANPA13CPRC_sc_audio@Z"}) 
	double CPRC_sc_audio_start_time(Pointer audio);
	/**
	 * Clean up an sound cue<br>
	 * Audio cues created using CPRC_sc_audio_short() or<br>
	 * CPRC_sc_audio_short_alloc() must be cleaned up by the user. They are<br>
	 * reatined in memory after playing so that timing information can be<br>
	 * acessed.<br>
	 * Original signature : <code>void CPRC_sc_audio_delete(CPRC_sc_audio*)</code><br>
	 * <i>native declaration : line 151</i>
	 */
	@Mangling({"_Z20CPRC_sc_audio_deleteP13CPRC_sc_audio", "?CPRC_sc_audio_delete@@YAXPA13CPRC_sc_audio@Z"}) 
	void CPRC_sc_audio_delete(Pointer audio);
	/**
	 * Reset and play an audio sound cue <br>
	 * This function resets the player and starts playing the cue supplied.<br>
	 * To cue up audio for playback in a stream, use CPRC_sc_audio_cue().<br>
	 * Original signature : <code>int CPRC_sc_audio_play(CPRC_sc_player*, CPRC_sc_audio*)</code><br>
	 * <i>native declaration : line 158</i>
	 */
	@Mangling({"_Z18CPRC_sc_audio_playP14CPRC_sc_playerP13CPRC_sc_audio", "?CPRC_sc_audio_play@@YAHPA14CPRC_sc_playerPA13CPRC_sc_audio@Z"}) 
	int CPRC_sc_audio_play(Pointer player, Pointer cue);
	/**
	 * Cue up an audio sound cue <br>
	 * Adds the cue to the list of currently playing sounds.  The cue will be<br>
	 * played when previously cued audio has finished playing.  If no audion<br>
	 * is playing, behaviour is is the same as CPRC_sc_audio_play().<br>
	 * Original signature : <code>CPRCTHD_CUE CPRC_sc_audio_cue(CPRC_sc_player*, CPRC_sc_audio*)</code><br>
	 * <i>native declaration : line 166</i>
	 */
	@Mangling({"_Z17CPRC_sc_audio_cueP14CPRC_sc_playerP13CPRC_sc_audio", "?CPRC_sc_audio_cue@@YA11CPRCTHD_CUEPA14CPRC_sc_playerPA13CPRC_sc_audio@Z"}) 
	/**
	 * @see CPRCTHD_CUE
	 */int CPRC_sc_audio_cue(Pointer player, Pointer cue);
	/**
	 * Sleep for this many milliseconds<br>
	 * Based on PortAudio internal cross platform sleep function,<br>
	 * used to help synchronise audio events.<br>
	 * Original signature : <code>void CPRC_sc_sleep_msecs(int)</code><br>
	 * <i>native declaration : line 174</i>
	 */
	@Mangling({"_Z19CPRC_sc_sleep_msecsi", "?CPRC_sc_sleep_msecs@@YAXH@Z"}) 
	void CPRC_sc_sleep_msecs(int msecs);
	/**
	 * TRUE if the player is playing audio<br>
	 * Original signature : <code>int CPRC_sc_audio_busy(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 177</i>
	 */
	@Mangling({"_Z18CPRC_sc_audio_busyP14CPRC_sc_player", "?CPRC_sc_audio_busy@@YAHPA14CPRC_sc_player@Z"}) 
	int CPRC_sc_audio_busy(Pointer player);
	/**
	 * Pause playback<br>
	 * Returns TRUE if player can be paused.<br>
	 * Original signature : <code>int CPRC_sc_audio_pauseon(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 183</i>
	 */
	@Mangling({"_Z21CPRC_sc_audio_pauseonP14CPRC_sc_player", "?CPRC_sc_audio_pauseon@@YAHPA14CPRC_sc_player@Z"}) 
	int CPRC_sc_audio_pauseon(Pointer player);
	/**
	 * Resume playback<br>
	 * Returns TRUE if player can be restarted.<br>
	 * Original signature : <code>int CPRC_sc_audio_pauseoff(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 189</i>
	 */
	@Mangling({"_Z22CPRC_sc_audio_pauseoffP14CPRC_sc_player", "?CPRC_sc_audio_pauseoff@@YAHPA14CPRC_sc_player@Z"}) 
	int CPRC_sc_audio_pauseoff(Pointer player);
	/**
	 * Stop playback<br>
	 * Returns TRUE if the player can be halted<br>
	 * Original signature : <code>int CPRC_sc_audio_stop(CPRC_sc_player*)</code><br>
	 * <i>native declaration : line 195</i>
	 */
	@Mangling({"_Z18CPRC_sc_audio_stopP14CPRC_sc_player", "?CPRC_sc_audio_stop@@YAHPA14CPRC_sc_player@Z"}) 
	int CPRC_sc_audio_stop(Pointer player);
	/// Undefined type
	public static interface CPRC_sc_player {
		
	};
	/// Undefined type
	public static interface CPRC_sc_audio {
		
	};
}
